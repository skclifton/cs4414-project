{"name":"cs4414-project","tagline":"","body":"# Concurrency and Threads in Rust 0.10\r\n\r\n## Processes vs. Threads\r\nBoth threads and processes are abstractions the operating system provides. Through the process abstraction, we can provide each program with the illusion that it owns the machine it is running on. This means giving each program its own address space, stack, registers and program counter, in addition to CPU time. Switching from a running process to a waiting process then requires the processor to make a context switch. This context switch involves saving the current thread's state to a process control block and restoring the state of the sleeping process. When making the context switch from one process to another we also have to switch address spaces, which is a fairly expensive process.\r\n\r\nA thread is a bit smaller than a process, and is often defined as the smallest possible unit of schedulable computation. Each thread retains the ability to execute a sequence of instructions by having separate program counters, registers and stack, threads share an address space. This means a context switch between threads does not require switching the address space, and can be done with lower cost.\r\n\r\n### Cost of Creation\r\nSince processes have their own address space, whenever a new process is created, this address space must also be created. Threads are therefore lighter to create, as they attach to existing address space instead of having to allocate new space in memory.\r\n\r\n### Shared Memory\r\nSince threads share address space it is relatively easy for programmers to have them communicate. Processes are more difficult, and either require the use of special interfaces like pipes and message passing or very careful manual memory management.\r\n\r\n##Tasks in Rust\r\n\r\nRust tasks are a special type of thread. While tasks share memory space, only immutable memory can be shared.\r\nWhen spawning a task you provide a closure to pass to the function. By only accepting owned closures, Rust can limit data shared between tasks to immutable data, since the parent task owns the data and allows child tasks to reference it. As soon as a child task tries to modify that owned box, that child task would have to take ownership of the box, violating the closure. Beyond closures, any type that is of the ```Send``` kind can be passed between tasks. ```Send``` types can only contain owned types, and thus do not violate ownership rules, but do not need to be explicitly stated as closures.\r\n\r\n\r\n### Native Thread vs. Green Thread\r\nThe default native thread uses one-to-one scheduling to map tasks to operating system (OS) kernel provided threads. Stated simply, for every task created by the user, there is a separate OS thread in which the task is run. \r\n\r\n\r\n#### Example 1: Thread Creation\r\n```rust\r\nuse std::task;\r\n\r\nfn printStr(s: &str) {\r\n    println!( \"{:s}\", s );\r\n}       \r\n\r\nfn main() {\r\n    task::spawn( proc(){ printStr(\"A\"); });\r\n    task::spawn( proc(){ printStr(\"B\"); });\r\n}\r\n```\r\n\r\nIn Example 1, a simple task is created. Since we did not specify which task library to use, these tasks will be created using the native thread model, with each task having its corresponding kernel thread. In this simple example there is no need for shared data.\r\n\r\n### Shared Memory Space\r\nAs stated before, the shared memory space of Rust tasks is immutable. However, Rust does allow programmers to disregard the built-in safety mechanisms and access memory unsafely as show in Example 2.\r\n\r\n\r\n#### Example 2: Failed Data Sharing\r\n\r\n```rust\r\nuse std::task;\r\n\r\nstatic mut count: int = 0;\r\n\r\nfn main() {\r\n    \r\n    for _ in range(0, 10000) {\r\n        task::spawn( proc(){\r\n            for _ in range(0, 100) {\r\n                unsafe {\r\n                    count += 1;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    \r\n    println!(\"Result should be 1,000,000\");\r\n    unsafe {\r\n        println!(\"main: done with both count = {}\", count);\r\n    }  \r\n    \r\n}\r\n\r\n```\r\nHere, 10,000 threads are created and each increments a global mutable variable 100 times. Even though the simple increment operation ```count += 1;``` seems like it should be atomic is not guaranteed to be, and since we do not control the scheduling of each task any task can access count and perform this increment at anytime. This will often lead to incorrect results. Beyond incorrect results, the results are inconsistent, making this a very difficult bug to identify and fix in a more complex program.\r\n\r\nThe solution to our problem is to safely share this data. Rust provides several higher-level data structures that control access to memory. Example 3 shows two of these, the Arc and RWLock structures.\r\n\r\n#### Example 3: Safe Data Sharing\r\n\r\n```rust\r\nextern crate sync;\r\n\r\nuse sync::{RWLock, Arc};\r\n\r\nfn main() {    \r\n\r\n    let lock1 = Arc::new(RWLock::new(0));\r\n    \r\n    for _ in range(0, 10000) {\r\n    \r\n        let lock2 = lock1.clone();\r\n        \r\n        spawn(proc() {\r\n        \r\n            let mut count = lock2.write();\r\n            \r\n            println!(\"before -  count = {}\", *count);\r\n            for _ in range (0, 100) {\r\n                *count += 1;\r\n            }\r\n            \r\n            let count = count.downgrade();\r\n            \r\n            println!(\"after -  count = {}\", *count);\r\n        });\r\n    }\r\n    \r\n    println!(\"Result should be 1000000\");\r\n    println!(\"Counter is: {}\", *lock1.read());\r\n}\r\n```\r\n\r\nIn this example, an Arc is used to share data between tasks. An acronym for Atomically Reference Counted data, the Arc creates a pointer to share data between tasks. Since it is owned by the start task, and each task gets a unique cloned version, it is immutable and can be safely passed into owned closures. The Arc only provides a pointer to share a memory location between tasks, and doesn't guarantee any form of safe or controlled access though. To control access to the data here, we must use a RWLock or similar type. The RWLock allows multiple tasks to read data, an immutable action, from that portion of memory. When a task needs to mutate the RWLock data, it must request write privileges. When these are granted, all other tasks trying to access the data will block until the writing task is finished and has relinquished control.\r\n\r\nOf course, sometimes we want to look at the underlying structures used for this. Example 4 shows how we can safely share data between tasks using senders and receivers.\r\n\r\n#### Example 4: Senders, Reciervers and a Channel\r\n\r\n```rust\r\nuse std::task;\r\nuse std::comm::channel;\r\n\r\nfn main() {\r\n    let mut count: int = 0;\r\n    \r\n    for _ in range(0, 10000) {\r\n        let (tx, rx) = channel();\r\n        let count2 = count;\r\n        \r\n        task::spawn( proc(){ \r\n            let mut mut_count = count2;\r\n            \r\n\t    for _ in range (0,100) {\r\n                mut_count += 1;\r\n            }\r\n            tx.send(mut_count);\r\n        });\r\n        count = rx.recv();\r\n    }\r\n    \r\n    println!(\"Result should be 1000000\");\r\n    println!(\"main: done with both count = {}\", count);\r\n}\r\n```\r\nSimilar to the previous example, we need a way to pass data from the parent task to the child tasks and then in between each child task. The most basic way Rust does this is through the creation of a ```channel()```, with a ```Sender``` type on one end and a ```Receiver``` type on the other end. In this example we pass data from the parent task to child tasks through an immutable variable, so ```Senders``` and ```Receivers``` are only needed to communicate from the child threads back to the parent thread. Within the ```for``` loop to spawn a new thread we declare a Sender, ```tx``` and a Receiver ```rx```, that allow the soon to be spawned child task to send data back to its parent.\r\n\r\n#### Example 5: Thread Waiting\r\n\r\n```rust\r\nuse std::task;\r\n\r\nstatic mut counter : uint = 0;\r\n\r\nfn mytask(s: &str) {\r\n    println!(\"before {:s}\", s);\r\n    for _ in range(0, 100) {\r\n        unsafe {\r\n            counter += 1;\r\n        }\r\n    }\r\n    println!(\"after {:s}\", s);\r\n}\r\n\r\nfn main() {\r\n    \r\n    for i in range(0, 10000) {\r\n        let result: Result<~str, ~std::any::Any:Send> = task::try(proc() { \r\n            mytask(i.to_str()); \r\n            ~\"Done\" });\r\n        assert!(result.is_ok());\r\n    }\r\n\r\n    println!(\"Result should be 1000000\");\r\n    unsafe {\r\n        println!(\"main: done with both counter = {:u}\", counter);\r\n    }\r\n}\r\n```\r\n\r\n## Try it!\r\n\r\n#### Example 6: Deadlock\r\n\r\n```rust\r\nextern crate sync;\r\n\r\nuse sync::{Mutex, Arc};\r\n\r\nfn increment( count: int) -> int{\r\n    return count + 1;    \r\n}\r\n\r\nfn main() {    \r\n\r\n    let mutex1 = Arc::new(Mutex::new(0));\r\n    let mutex2 = mutex1.clone();\r\n        \r\n    spawn(proc() {\r\n    \r\n        let mut val = mutex2.lock();\r\n        *val = increment(*val);\r\n        \r\n\r\n    });\r\n    \r\n    let value = mutex1.lock();\r\n    while *value != 2 {\r\n        value.cond.wait();\r\n    }\r\n    \r\n    println!(\"Lock was never released in spawned proc(), so I will never be reached!\");\r\n}\r\n```\r\n1. Explain why this code deadlocks.\r\n2. Use different features of Rust to write your own program that deadlocks.\r\n\r\n## References\r\nArpaci-Dusseau, Andrea and Remzi. Operating Systems: Three Easy Pieces. http://pages.cs.wisc.edu/~remzi/OSTEP/\r\n\r\nEvans, David. University of Virginia, CS 4414: Operating Systems. Spring 2014\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}