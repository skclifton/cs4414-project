{"name":"cs4414-project","tagline":"","body":"# Concurrency and Threads in Rust 0.10\r\n\r\n\r\n### Example 1: Thread Creation\r\n```rust\r\nuse std::task;\r\n\r\nfn printStr(s: &str) {\r\n    println!( \"{:s}\", s );\r\n}\t\r\n\r\nfn main() {\r\n    task::spawn( proc(){ printStr(\"A\"); });\r\n    task::spawn( proc(){ printStr(\"B\"); });\r\n}\r\n```\r\n\r\n\r\n### Example 2: Failed Data Sharing\r\n\r\n```rust\r\nuse std::task;\r\n\r\nstatic mut count: int = 0;\r\n\r\n\r\nfn increment( count: int) -> int{\r\n    return count + 1;    \r\n}\r\n\r\nfn main() {\r\n    \r\n    for i in range(0, 10000) {\r\n        task::spawn( proc(){ \r\n            println!(\"before {:s}\", i.to_str());\r\n            for _ in range(0, 100) {\r\n                unsafe {\r\n                    println!(\"before - count is: {}\", count);\r\n                    count = increment(count);\r\n                    println!(\"after - count is: {}\", count);\r\n                }\r\n            }\r\n        println!(\"after {:s}\", i.to_str());\r\n        });\r\n    }\r\n    \r\n    println!(\"Result should be 1000000\");\r\n    unsafe {\r\n        println!(\"main: done with both count = {}\", count);\r\n    }\r\n}\r\n```\r\n\r\n\r\n### Example 3: Safe Data Sharing\r\n\r\n```rust\r\nextern crate sync;\r\n\r\nuse sync::{RWLock, Arc};\r\n\r\nfn increment( count: int) -> int{\r\n    return count + 1;    \r\n}\r\n\r\nfn main() {    \r\n\r\n    let lock1 = Arc::new(RWLock::new(0));\r\n    \r\n    for _ in range(0, 10000) {\r\n    \r\n        let lock2 = lock1.clone();\r\n        \r\n        spawn(proc() {\r\n        \r\n            let mut count = lock2.write();\r\n            \r\n            println!(\"before -  count = {}\", *count);\r\n            for _ in range (0, 100) {\r\n                *count = increment(*count);\r\n            }\r\n            \r\n            let count = count.downgrade();\r\n            \r\n            println!(\"after -  count = {}\", *count);\r\n        });\r\n    }\r\n    \r\n    println!(\"Result should be 1000000\");\r\n    println!(\"Counter is: {}\", *lock1.read());\r\n}\r\n```\r\n\r\n### Example 4: Ports and Channels\r\n\r\n```rust\r\nuse std::task;\r\nuse std::comm::channel;\r\n\r\nfn increment( count: int) -> int{\r\n    return count + 1;    \r\n}\r\n\r\nfn main() {\r\n    let mut count: int = 0;\r\n    let (tx, rx)  = channel();\r\n    \r\n    for _ in range(0, 10000) {\r\n        let child_tx = tx.clone();\r\n        let (chano, porto) = channel();\r\n        child_tx.send(2);\r\n        let count2 = count;\r\n        \r\n        task::spawn( proc(){ \r\n            let mut mut_count = count2;\r\n            println!(\"mutable count before: {}\", mut_count);\r\n            for _ in range (0,100) {\r\n                mut_count = increment(mut_count);\r\n            }\r\n            println!(\"mutable count after: {}\", mut_count);\r\n            chano.send(mut_count);\r\n        });\r\n        count = porto.recv();\r\n    }\r\n    \r\n    println!(\"Result should be 1000000\");\r\n    println!(\"main: done with both count = {}\", count);\r\n}\r\n```\r\n\r\n\r\n### Example 5: Thread Waiting\r\n\r\n```rust\r\nuse std::task;\r\n\r\nstatic mut counter : uint = 0;\r\n\r\nfn mytask(s: &str) {\r\n    println!(\"before {:s}\", s);\r\n    for _ in range(0, 100) {\r\n        unsafe {\r\n            counter += 1;\r\n        }\r\n    }\r\n    println!(\"after {:s}\", s);\r\n}\r\n\r\nfn main() {\r\n    \r\n    for i in range(0, 10000) {\r\n        let result: Result<~str, ~std::any::Any:Send> = task::try(proc() { \r\n            mytask(i.to_str()); \r\n            ~\"Done\" });\r\n        assert!(result.is_ok());\r\n    }\r\n\r\n    println!(\"Result should be 1000000\");\r\n    unsafe {\r\n        println!(\"main: done with both counter = {:u}\", counter);\r\n    }\r\n}\r\n```\r\n\r\n\r\n### Example 6: Deadlock\r\n\r\n```rust\r\nextern crate sync;\r\n\r\nuse sync::{Mutex, Arc};\r\n\r\nfn increment( count: int) -> int{\r\n    return count + 1;    \r\n}\r\n\r\nfn main() {    \r\n\r\n    let mutex1 = Arc::new(Mutex::new(0));\r\n    let mutex2 = mutex1.clone();\r\n        \r\n    spawn(proc() {\r\n    \r\n        let mut val = mutex2.lock();\r\n        *val = increment(*val);\r\n        \r\n\r\n    });\r\n    \r\n    let value = mutex1.lock();\r\n    while *value != 2 {\r\n        value.cond.wait();\r\n    }\r\n    \r\n    println!(\"Lock was never released in spawned proc(), so I will never be reached!\");\r\n}\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}